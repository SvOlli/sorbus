; Copyright (c) 2025 Sven Oliver "SvOlli" Moll
;
; SPDX-License-Identifier: GPL-3.0-or-later
;
.pio_version 0

; GPIOs in use are
;  5: !CS
; 18: D0
; 19: D1
; [...]
; 25: D7
; 26: R/!W
; 27: CLK
; 28: !IRQ/A0
; 29: !NMI

.program vga_bus_handler

.define CS        5
.define CLK       27
.define inpins    11
.define outpins   8

.wrap_target
loop:
   wait 0 gpio CS       ; first wait for CS to go low
   wait 1 gpio CLK      ; wait for CLK to go high
   jmp pin read         ; high signal indecades a read by CPU

write:                  ; CPU perfoms a write, VGA needs to fetch data from bus
   nop              [1] ; wait for bus to settle
   in pins, inpins      ; read databus + 2 dummy bits + A0
   irq 0
   jmp done

read:                   ; CPU perfoms a read, VGA needs to provide data on bus
   out pins, outpins
   mov osr, !null
   out pindirs, outpins

done:
   wait 0 gpio CLK      ; wait for CLK to go low
   wait 1 gpio CS       ; wait for CS to be done
   mov osr, null
   out pindirs, outpins
.wrap

% c-sdk {
#include "hardware/clocks.h"

static PIO  vga_bus_pio;
static uint vga_bus_sm;

static inline void vga_bus_handler_program_init( PIO pio, uint sm, uint offset, float freq )
{
   // other values don't make sense
   const uint startpin    = 18; // D7
   const uint outpins     = vga_bus_handler_outpins;
   const uint inpins      = vga_bus_handler_inpins;  // to get A0 as well
   const uint rwpin       = 26;

   vga_bus_pio = pio;
   vga_bus_sm  = sm;

   pio_gpio_init( pio, startpin );

   // setup pins
   pio_sm_config c = vga_bus_handler_program_get_default_config( offset );
   sm_config_set_in_pin_base( &c, startpin );
   sm_config_set_in_pin_count( &c, inpins );
   sm_config_set_out_pin_base( &c, startpin );
   sm_config_set_out_pin_count( &c, outpins );
   // start with data direction set to read, extra pins are up to A0
   pio_sm_set_consecutive_pindirs( pio, sm, startpin, inpins, false );

   sm_config_set_fifo_join( &c, PIO_FIFO_JOIN_NONE );
   sm_config_set_in_shift( &c, false, true, inpins );
   sm_config_set_out_shift( &c, false, true, outpins );

   // running the PIO sm 20 times as fast as expected CPU address
   float div = clock_get_hz( clk_sys ) / (freq * 20);
   sm_config_set_clkdiv( &c, div );

   pio_sm_set_jmp_pin( pio, sm, rwpin );
   pio_sm_init( pio, sm, offset, &c );
   pio_sm_set_enabled( pio, sm, true );
}

// returns bus as 0x00-0xff: data + 0x400 when A0 set
static inline uint32_t vga_bus_read()
{
   return (pio_sm_get_blocking( vga_bus_pio, vga_bus_sm ) >> 18) & 0x4FF;
}

static inline void vga_bus_write( uint8_t data )
{
   pio_sm_put_blocking( vga_bus_pio, vga_bus_sm, data );
}
%}
